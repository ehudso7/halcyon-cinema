import JSZip from 'jszip';
import { Project, Scene } from '@/types';

export interface ExportOptions {
  includeImages?: boolean;
  includePrompts?: boolean;
  includeMetadata?: boolean;
}

async function fetchImageAsBase64(url: string): Promise<string | null> {
  try {
    const response = await fetch(url);
    if (!response.ok) return null;

    const buffer = await response.arrayBuffer();
    return Buffer.from(buffer).toString('base64');
  } catch {
    console.error('Failed to fetch image:', url);
    return null;
  }
}

export async function exportProjectAsZip(
  project: Project,
  options: ExportOptions = {}
): Promise<Buffer> {
  const {
    includeImages = true,
    includePrompts = true,
    includeMetadata = true,
  } = options;

  const zip = new JSZip();

  // Create project info file
  const projectInfo = {
    name: project.name,
    description: project.description,
    sceneCount: project.scenes.length,
    createdAt: project.createdAt,
    updatedAt: project.updatedAt,
    exportedAt: new Date().toISOString(),
  };

  zip.file('project-info.json', JSON.stringify(projectInfo, null, 2));

  // Create a README with project overview
  const readme = generateReadme(project);
  zip.file('README.txt', readme);

  // Create scenes folder
  const scenesFolder = zip.folder('scenes');

  if (!scenesFolder) {
    throw new Error('Failed to create scenes folder');
  }

  // Process each scene
  for (let i = 0; i < project.scenes.length; i++) {
    const scene = project.scenes[i];
    const sceneNumber = String(i + 1).padStart(3, '0');
    const sceneFolder = scenesFolder.folder(`scene-${sceneNumber}`);

    if (!sceneFolder) continue;

    // Add prompt file
    if (includePrompts) {
      const promptContent = formatPromptFile(scene, i + 1);
      sceneFolder.file('prompt.txt', promptContent);
    }

    // Add metadata file
    if (includeMetadata && scene.metadata) {
      const metadataContent = JSON.stringify(
        {
          id: scene.id,
          prompt: scene.prompt,
          metadata: scene.metadata,
          createdAt: scene.createdAt,
          updatedAt: scene.updatedAt,
        },
        null,
        2
      );
      sceneFolder.file('metadata.json', metadataContent);
    }

    // Add image
    if (includeImages && scene.imageUrl) {
      const imageBase64 = await fetchImageAsBase64(scene.imageUrl);
      if (imageBase64) {
        sceneFolder.file('image.png', imageBase64, { base64: true });
      }
    }
  }

  // Generate all prompts file
  if (includePrompts) {
    const allPrompts = project.scenes
      .map((scene, i) => `Scene ${i + 1}:\n${scene.prompt}`)
      .join('\n\n---\n\n');
    zip.file('all-prompts.txt', allPrompts);
  }

  // Generate the ZIP file
  const zipBuffer = await zip.generateAsync({
    type: 'nodebuffer',
    compression: 'DEFLATE',
    compressionOptions: { level: 6 },
  });

  return zipBuffer;
}

export async function exportSceneAsZip(scene: Scene, sceneIndex: number): Promise<Buffer> {
  const zip = new JSZip();

  // Add prompt
  const promptContent = formatPromptFile(scene, sceneIndex);
  zip.file('prompt.txt', promptContent);

  // Add metadata
  if (scene.metadata) {
    const metadataContent = JSON.stringify(
      {
        id: scene.id,
        prompt: scene.prompt,
        metadata: scene.metadata,
        createdAt: scene.createdAt,
        updatedAt: scene.updatedAt,
      },
      null,
      2
    );
    zip.file('metadata.json', metadataContent);
  }

  // Add image
  if (scene.imageUrl) {
    const imageBase64 = await fetchImageAsBase64(scene.imageUrl);
    if (imageBase64) {
      zip.file('image.png', imageBase64, { base64: true });
    }
  }

  const zipBuffer = await zip.generateAsync({
    type: 'nodebuffer',
    compression: 'DEFLATE',
  });

  return zipBuffer;
}

function generateReadme(project: Project): string {
  const lines = [
    `HALCYON-Cinema Project Export`,
    `=============================`,
    ``,
    `Project: ${project.name}`,
    project.description ? `Description: ${project.description}` : '',
    `Scenes: ${project.scenes.length}`,
    `Created: ${new Date(project.createdAt).toLocaleString()}`,
    `Exported: ${new Date().toLocaleString()}`,
    ``,
    `Contents:`,
    `---------`,
    `- project-info.json  Project metadata`,
    `- all-prompts.txt    All scene prompts`,
    `- scenes/            Individual scene folders`,
    `  - scene-XXX/`,
    `    - prompt.txt     Scene prompt`,
    `    - metadata.json  Scene metadata`,
    `    - image.png      Generated image`,
    ``,
    `Generated by HALCYON-Cinema`,
    `https://halcyon-cinema.vercel.app`,
  ].filter(Boolean);

  return lines.join('\n');
}

function formatPromptFile(scene: Scene, sceneNumber: number): string {
  const lines = [
    `Scene ${sceneNumber}`,
    `${'='.repeat(20)}`,
    ``,
    `Prompt:`,
    scene.prompt,
    ``,
  ];

  if (scene.metadata) {
    lines.push(`Metadata:`);
    if (scene.metadata.shotType) lines.push(`- Shot Type: ${scene.metadata.shotType}`);
    if (scene.metadata.style) lines.push(`- Style: ${scene.metadata.style}`);
    if (scene.metadata.lighting) lines.push(`- Lighting: ${scene.metadata.lighting}`);
    if (scene.metadata.mood) lines.push(`- Mood: ${scene.metadata.mood}`);
    if (scene.metadata.aspectRatio) lines.push(`- Aspect Ratio: ${scene.metadata.aspectRatio}`);
    lines.push(``);
  }

  lines.push(`Created: ${new Date(scene.createdAt).toLocaleString()}`);

  return lines.join('\n');
}
